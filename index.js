// Generated by CoffeeScript 2.4.1
// Mixin definition
export default {
  // Public interface
  props: {
    // Add listeners and check if in viewport immediately
    inViewportActive: {
      type: Boolean,
      default: true
    },
    // Only update once by default. The assumption is that it will be used for
    // one-time buildins
    inViewportOnce: {
      type: Boolean,
      default: false
    },
    inViewportContainer: {
      type: String,
      default: null
    },
    // Shared offsets
    inViewportOffset: {
      type: Number,
      default: 0
    },
    inViewportOffsetTop: {
      type: Number,
      default: null
    },
    inViewportOffsetBottom: {
      type: Number,
      default: null
    }
  },
  // Bindings that are used by the host component
  data: function () {
    return {
      inViewport: {
        // Public props
        now: null,
        // Is in viewport
        fully: null,
        // Is fully in viewport
        above: null,
        // Is partially or fully above the viewport
        below: null,
        // Is partially or fully below the viewport
        // Internal props
        listening: false
      }
    };
  },
  // Use general offset if none are defined
  computed: {
    inViewportOffsetTopComputed: function () {
      var ref;
      return (ref = this.inViewportOffsetTop) != null ? ref : this.inViewportOffset;
    },
    inViewportOffsetBottomComputed: function () {
      var ref;
      return (ref = this.inViewportOffsetBottom) != null ? ref : this.inViewportOffset;
    },
    inViewportOffsetComputed: function () {
      return {
        top: this.inViewportOffsetTopComputed,
        bottom: this.inViewportOffsetBottomComputed
      };
    }
  },
  // Lifecycle hooks
  mounted: function () {
    return this.$nextTick(this.inViewportInit);
  },
  destroyed: function () {
    return this.removeInViewportHandlers();
  },
  // Watch props and data
  watch: {
    // Add or remove event handlers handlers
    inViewportActive: function (active) {
      if (active) {
        return this.addInViewportHandlers();
      } else {
        return this.removeInViewportHandlers();
      }
    },
    // If the offsets change, need to rebuild scrollMonitor instance because it
    // doesn't offer an API to update the offset
    inViewportOffsetComputed: {
      deep: true,
      handler: function () {
        this.removeInViewportHandlers();
        return this.inViewportInit();
      }
    }
  },
  // Public API
  methods: {
    // Instantiate
    inViewportInit: function () {
      if (this.inViewportActive) {
        return this.addInViewportHandlers();
      }
    },
    // Add listeners
    addInViewportHandlers: function () {
      // Don't add twice
      if (this.inViewport.listening) {
        return;
      }

      this.inViewport.listening = true; // Create scrollMonitor instance which starts watching scroll

      if (this.inViewportContainer) {
        this.scrollMonitor = scrollMonitor.createContainer(this.inViewportContainer).create(this.$el, this.inViewportOffsetComputed);
      } else {
        this.scrollMonitor = scrollMonitor.create(this.$el, this.inViewportOffsetComputed);
      } // Start listening for changes


      this.scrollMonitor.on('stateChange', this.updateInViewport); // Update intiial state, which also handles `once` prop

      return this.updateInViewport();
    },
    // Remove listeners
    removeInViewportHandlers: function () {
      // Don't remove twice
      if (!this.inViewport.listening) {
        return;
      }

      this.inViewport.listening = false;

      if (this.scrollMonitor) {
        // Destroy instance, which also removes listeners
        this.scrollMonitor.destroy();
      }

      return delete this.scrollMonitor;
    },
    // Handle state changes from scrollMonitor
    updateInViewport: function () {
      // Update state values
      this.inViewport.now = this.scrollMonitor.isInViewport;
      this.inViewport.fully = this.scrollMonitor.isFullyInViewport;
      this.inViewport.above = this.scrollMonitor.isAboveViewport;
      this.inViewport.below = this.scrollMonitor.isBelowViewport;

      if (this.inViewportOnce && this.inViewport.now) {
        // If set to update "once", remove listeners if in viewport
        return this.removeInViewportHandlers();
      }
    }
  }
};